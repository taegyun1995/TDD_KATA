# Java 자동차 경주 게임

TDD와 단위 테스트 학습을 위한 간단한 콘솔 기반의 자동차 경주 게임 애플리케이션입니다.

## 📚 학습 목표
- 랜덤 값에 의존하는 코드를 테스트하는 방법 (의존성 주입)
- 입력값 검증 및 예외 처리 테스트
- 객체 간 협력 관계 설계
- 전략 패턴(Strategy Pattern) 이해

---

## 🎯 기능 요구사항

아래 요구사항을 한 단계씩 순서대로 TDD 사이클에 맞춰 개발합니다.

### Step 1. Car 생성 및 이름 검증
- `Car` 객체를 이름으로 생성할 수 있다.
- 자동차 이름은 **5자 이하**만 가능하다.
- 이름이 공백이거나 5자를 초과할 경우 `IllegalArgumentException`을 발생시킨다.

### Step 2. Car 전진 기능
- `Car`는 `position`을 가지며, 초기값은 `0`이다.
- `move()` 메소드를 호출하면 `position`이 1 증가한다.

### Step 3. 전진 조건 (의존성 주입)
- 0에서 9 사이의 값을 받아, **4 이상이면 전진**하고 **3 이하이면 멈춘다**.
- 랜덤 값 생성을 외부에서 주입받을 수 있도록 `NumberGenerator` 인터페이스를 활용한다.
- 테스트에서는 고정값을 주입하여 전진/정지를 검증한다.

### Step 4. Cars 일급 컬렉션
- 여러 대의 자동차를 관리하는 `Cars` 클래스를 생성한다.
- 모든 자동차를 한 번씩 이동시키는 `moveAll()` 메소드를 구현한다.

### Step 5. 우승자 판별
- `Cars`에서 가장 멀리 이동한 자동차(들)를 찾는다.
- 우승자가 여러 명일 경우, 모두 반환한다.

### Step 6. 입력값 파싱
- 쉼표(`,`)로 구분된 자동차 이름 문자열을 파싱하여 `Cars`를 생성한다.
- 시도 횟수 문자열을 파싱하여 정수로 변환한다.
- 시도 횟수가 숫자가 아니거나, 0 이하일 경우 예외를 발생시킨다.

### Step 7. 게임 진행
- `RacingGame` 클래스에서 시도 횟수만큼 `Cars`를 이동시킨다.
- 각 라운드별 결과를 기록한다.

---

## 🚀 심화 기능 요구사항 (선택)

### Step 8. 결과 출력
- 각 라운드별로 모든 자동차의 이동 결과를 출력한다.
- 이동한 거리는 하이픈(`-`)으로 표현한다.
  ```
  pobi : --
  woni : -
  jun : ---
  ```

### Step 9. 다양한 전진 전략
- 전진 규칙(전략)을 외부에서 주입받아 변경할 수 있도록 설계한다.
- 예: 항상 전진하는 전략, 특정 조건에서만 전진하는 전략 등

---

## 💡 랜덤 값 테스트 TIP

랜덤에 의존하는 코드를 테스트하기 어려울 때, **의존성 주입**을 활용합니다.

```java
// 인터페이스 정의
@FunctionalInterface
public interface NumberGenerator {
    int generate();
}

// 프로덕션 코드에서는 랜덤 생성기 사용
NumberGenerator randomGenerator = () -> new Random().nextInt(10);

// 테스트에서는 고정값 생성기 사용
NumberGenerator fixedGenerator = () -> 4;
```

---

## ✅ 프로그래밍 요구사항
- 모든 기능은 TDD(Test-Driven Development) 방식으로 개발한다.
- **한 번에 하나의 테스트 케이스만 통과시키고, 다음 단계로 넘어간다.**
- 모든 기능 단위에 대한 단위 테스트를 작성한다.
- Java 코드 컨벤션을 지키면서 프로그래밍한다.
- 함수(메서드)는 한 가지 기능만 담당하도록 최대한 작게 만든다.
- 테스트 라이브러리는 **JUnit 5**와 **AssertJ**를 사용한다.
