# Java 자판기

TDD와 단위 테스트 학습을 위한 간단한 콘솔 기반의 자판기(Vending Machine) 시뮬레이션입니다.
'상태(State)'를 가진 객체를 테스트하는 방법을 연습하는 데 중점을 둡니다.

## 🎯 기능 요구사항

### 1. 자판기 초기화
- 자판기는 시작 시 상품 목록과 각 상품의 재고, 그리고 보유하고 있는 잔돈을 가지고 있어야 한다.
- 상품은 이름, 가격, 재고 정보를 가진다.

### 2. 돈 투입
- 사용자는 자판기에 돈을 투입할 수 있다.
- 투입된 금액은 자판기 내에 누적된다.

### 3. 상품 구매
- 사용자는 구매할 상품을 선택할 수 있다.
- **구매 불가 조건 (예외 발생):**
    - 투입한 금액이 선택한 상품의 가격보다 적을 경우
    - 선택한 상품의 재고가 없을 경우
- **구매 성공:**
    - 투입한 금액에서 상품 가격만큼 차감한다.
    - 상품의 재고를 1 감소시킨다.

### 4. 잔돈 반환
- 사용자가 '잔돈 반환'을 요청하면, 현재 투입되어 있는 금액을 모두 반환한다.
- 반환 후, 자판기에 투입된 금액은 0이 된다.

---

## 🖥️ 실행 결과 예시

```
===== 자판기 상품 =====
콜라(1000원) - 5개
사이다(1200원) - 3개
물(800원) - 10개
=====================
투입한 금액: 0원

돈을 투입하세요.
> 2000

투입한 금액: 2000원
구매할 상품을 선택하세요. (종료: '종료', 잔돈 반환: '반환')
> 콜라

'콜라'가 나왔습니다.
투입한 금액: 1000원
구매할 상품을 선택하세요. (종료: '종료', 잔돈 반환: '반환')
> 사이다

[ERROR] 금액이 부족합니다. 현재 투입된 금액은 1000원 입니다.
투입한 금액: 1000원
구매할 상품을 선택하세요. (종료: '종료', 잔돈 반환: '반환')
> 반환

잔돈 1000원을 반환합니다.
```

### 5. 거스름돈 동전 재고 관리
- 자판기가 보유하고 있는 동전(예: 500원, 100원, 50원, 10원)의 개수를 관리한다.
- 잔돈 반환 시, 단순히 총액을 반환하는 것이 아니라 보유한 동전들로 조합하여 반환한다.
- 만약 정확한 거스름돈을 줄 동전이 부족하다면, "잔돈 부족" 예외를 발생시키고 구매를 취소시킨다.
- (힌트: 그리디 알고리즘(Greedy Algorithm)을 적용하여 가장 큰 단위의 동전부터 거슬러주는 로직을 구현해볼 수 있습니다.)

### 6. 동시성 제어 (동시 구매 방지)
- 멀티쓰레드 환경에서 여러 사용자가 동시에 마지막 남은 상품을 구매하려는 상황을 고려합니다.
- 오직 하나의 구매 요청만 성공해야 하며, 상품의 재고가 음수(-)가 되는 일이 없어야 합니다.
- (힌트: 실제 멀티쓰레드 테스트는 복잡할 수 있으므로, `synchronized` 키워드 등을 적용하여 동시성을 제어하는 로직을 구현하고, 해당 로직이 단일 쓰레드 환경에서 의도대로 동작하는지 단위 테스트로 검증하는 것을 목표로 할 수 있습니다.)

---

## ✅ 프로그래밍 요구사항
- 모든 기능은 TDD(Test-Driven Development) 방식으로 개발한다.
- 자판기의 '상태'(투입된 돈, 상품 재고)가 행동(돈 투입, 상품 구매)에 따라 어떻게 변하는지를 중점적으로 테스트한다.
- 객체의 역할과 책임을 명확하게 분리한다. (예: `VendingMachine`, `Item`, `Money`)
- 테스트 라이브러리는 **JUnit 5**와 **AssertJ**를 사용한다.
